# _*_ coding=utf-8 _*_

import numpy as np

a = np.array([[1,2,3],[3,4,5],[4,5,6]]) # 3行3列的矩阵
print(a)
# 从某个索引处开始切割
print('从数组索引 a[1:] 处开始切割') # 也就是把三个子列表当做整体来操作
print(a[1:]) #坐标为1的子列表之后的所有子列表

# 如下，输出一个2行3列的数组
'''
[[1 2 3]
 [3 4 5]
 [4 5 6]]
从数组索引 a[1:] 处开始切割
[[3 4 5]
 [4 5 6]]
'''
print('***'*10) # 下面只取某一个子列表
print(a[1],type(a[1])) # 输出[3 4 5] <class 'numpy.ndarray'>

print('***'*10)
print(a[::2]) # 从头到尾但是步长为2
'''
[[1 2 3]
 [4 5 6]]
'''
print('***'*10)
print(a[::-1]) # 倒序取一遍
'''
[[4 5 6]
 [3 4 5]
 [1 2 3]]
'''

# 还可以定点的取第几行的第几个元素
print('***'*10)
print(a[1,2])  # 输出5，是获取第二行的，第三个元素，注意：这里中间分隔的是逗号
# 当numpy切片，逗号分开的时候，逗号用来区分维度，而冒号仅仅是索引
# 通俗的理解就是，当使用a[1:2]时，所有的操作都是在当前维度下进行的
# 而使用a[1,2]时，就可以跨维度操作，不再把每个子列表看作整体，而是深入行和列的内部
# 换言之，a[1,2]，逗号前面是行索引，逗号后面是列索引

y = np.array([
    [1,2,3],
    [4,5,6],
    [7,8,9],
    [11,12,13]])

b = y[2:, :1]  #逗号前面是行索引，所以是第三行到最后；逗号后面是列索引，:1是，第一列
print(b)

'''
[[ 7]
 [11]]
'''