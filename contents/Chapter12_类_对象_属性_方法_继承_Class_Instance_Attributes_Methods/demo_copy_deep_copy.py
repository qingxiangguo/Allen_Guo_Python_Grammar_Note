# Qingxiang Guo
# {2022/6/2} {12:08}
'''
这里讲浅拷贝与深拷贝。浅拷贝顾名思义，只是复制了第一层，第一层有独立性，和之前无关，但是更深层次的，还是指向相同的，由于节约内存，没有开一个新空间，修改受影响。
深拷贝指向一个全新的系列对象，不论有多少层，每一层都有自己的独立性，和之前无关。无论有多复杂的对象，拷贝了一份后，无论怎么修改自己都不会引起原来对象的变化叫深拷贝。
如果想让浅拷贝对象的更深层和原对象断掉，可以通过将更深层次的指向一个新的对象来实现。
浅拷贝实现方法：（1）python自带的.copy()方法。（2）copy模块里面的，copy.copy()
深拷贝实现方法：（1）copy模块里面的，copy.deepcopy()
注意：这里很多copy，命名方法容易混淆，要明白一个是自带的方法，一个是模块里面的子方法
'''

print('-------第一个例子-----------')
import copy
a=[1,2,3,[1,2,3,[5,6]]]  #一个嵌套列表对象
b=a  #这是普通的赋值操作，其实只是换了个名字而已，修改a也会影响b
a[0]=99
print(a)  #[99, 2, 3, [1, 2, 3, [5, 6]]]
print(b)  #[99, 2, 3, [1, 2, 3, [5, 6]]]

c1=a.copy()  #这是对a进行浅拷贝的第一种方法，利用自带函数
c1[3][0]= 9  #修改了[1, 2, 3, [5, 6]]中的1，由于这是深层，以及浅拷贝，所以会影响原本的a
print(c1)  #[99, 2, 3, [9, 2, 3, [5, 6]]]
print(a)   #[99, 2, 3, [9, 2, 3, [5, 6]]]  a也改变了

c1[1]=88   #修改第一层，浅层，下面可见不影响原来的a
print(c1)  #[99, 88, 3, [9, 2, 3, [5, 6]]]
print(a)   #[99, 2, 3, [9, 2, 3, [5, 6]]]

d=copy.deepcopy(a)  #对a进行一个深拷贝
d[3][3][0]=100  #修改[9, 2, 3, [5, 6]]中的[5, 6]中的5修改为100
print(d)  #[99, 2, 3, [9, 2, 3, [100, 6]]]
print(a)  #[99, 2, 3, [9, 2, 3, [5, 6]]]，可见就算修改深层，a也不变，这就是深拷贝

#在上面c1浅拷贝的例子中，如果想让浅拷贝对象的更深层和原对象断掉，可以通过将更深层次的指向一个新的对象来实现
print(a)  #[99, 2, 3, [9, 2, 3, [5, 6]]]
c1[3] = [0,1,2,3]
print(c1)  #[99, 88, 3, [0, 1, 2, 3]]
print(a)  #[99, 2, 3, [9, 2, 3, [5, 6]]]，可见a也没变，某种意义上实现了和深拷贝类似的效果

num=1
#num.copy()，会报错，如果是涉及到整数（不可变对象），一般指向不同对象。拷贝一般针对可变元素的（列表，集合，字典）
#拷贝的真正意义，是通过复制的方法，来防止修改时的冲突。整数作为不可变对象，没有什么拷贝的价值。

print('-------第二个字典的例子-----------')
import copy

dict1 =  {'name':'qingxiang','num':[1,2,3]}
dict2 = dict1  # 普遍的赋值操作，dict1变dict2也变
dict3 = dict1.copy()  # 浅拷贝，只保证第一层的独立性，不保证深层的独立性
dict4 = copy.deepcopy(dict1)  #深拷贝

# 修改 data 数据
dict1['name'] = 'root'
dict1['num'].remove(1)  #在列表中按元素删除1

# 输出结果
print(dict1)  #{'name': 'root', 'num': [2, 3]}
print(dict2)   #{'name': 'root', 'num': [2, 3]}  由于是普遍赋值操作，dict2也变了
print(dict3)   #{'name': 'qingxiang', 'num': [2, 3]}，，由于是浅拷贝，前面没变，但是列表里面变了
print(dict4)  #{'name': 'qingxiang', 'num': [1, 2, 3]}，没有变化，毫无影响
