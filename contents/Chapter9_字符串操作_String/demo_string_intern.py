# Qingxiang Guo
# {2022/5/12} {16:04}
'''
字符串的驻留机制，是仅保留一份相同且不可变字符串的一种方法。
不同的值被存放在字符串的驻留池中，python的驻留机制对相同的字符串
只保留一份拷贝，后续创建相同的字符串时，
不会开辟新空间，而是把该字符串的地址赋给新创建的变量
'''
#字符串驻留机制的几种情况
#第一种，字符串长度为0或1时
s1=''  #长度为0
s2=''
print(s1 is s2)  #看ID地址
print(id(s1), id(s2))
s1='%'  #长度为1
s2='%'
print(s1 is s2)  #
print(id(s1), id(s2))
#第二种，符合标识符的字符串，含有字母数字下划线的字符串
s1='abc%'   #%是不符合标识符的字符串
s2='abc%'
print(s1==s2)   #两者值是相等的
print(s1 is s2)  #True
print(id(s1),id(s2))  #两者ID一样，这里cmd交互式和pyCharm运行结果是相反的，phcharm做了优化
#下面是符合标识符的字符串
s1='abc_'   #%是不符合标识符的字符串
s2='abc_'
print(s1==s2)   #两者值是相等的
print(s1 is s2)  #True
print(id(s1),id(s2))  #两者ID一样，产生了字符串驻留
#第三种，字符串只在编译时驻留，而非运行时，运行函数之类的，会开一个新内存
a='abc'
b='ab'+'c'
c=''.join(['ab','c'])  #使用join函数将列表中ab与c元素连接成为字符串
print(a is b) #True，因为b在运行之前就已经合成了，所以触发了驻留，两者相同
print(a is c, type(c)) #False，因为c调用了函数，属于运行时，所以没有触发驻留，c相当于开了新内存
#第四种，-5到256之间的数字，会触发驻留
a=-6
b=-6
print(a is b)  #False，因为超过-5了

#由于字符串的驻留机制，有时候两个明明相同的字符串，但是python会给你分配两个内存空间
#所以这个时候可以使用sys.intern，确保永远不会创建具有相同值的两个字符串对象 ，来达到性能优化的目的
import sys
a='abc'
c=''.join(['ab','c'])
print(a is c)  #如上，两者不一样的内存空间，False
print(id(a),id(c))  #内存地址也不一样
#下面强行指向一个内存地址
c=sys.intern(a)  #注意，这里不能反过来，因为c是函数计算的，所以要把a的，赋予c，a在右边
print(a is c)   #True，因为现在a与c被强行指向同一个了
print(id(a),id(c))  #相同

#驻留机制有什么优缺点呢？
'''   当需要值相同的字符串时，可以直接从字符串池中拿来使用，避免频繁创建和销毁，
可以提升效率并节省内存，而拼接字符串和修改字符串时比较影响性能的。
在需要进行字符串拼接时建议使用str类型的join方法来代替连接符+，
因为join()方法会先计算出所有字符串的长度，然后再拷贝，期间只new一次对象，效率会比连接符+效率高
'''
